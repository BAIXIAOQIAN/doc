[TOC]

## TLS

SSL/TLS协议的基本思路是采用公钥加密法，也就是说，客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。

但是，这里有两个问题

- 如何保证公钥不被篡改
```
解决方法: 将公钥放在数字证书中，只要证书是可信的，公钥就是可信的。
```

- 公钥加密计算量太大，如何减少耗用的时间？
```
解决方法: 每一次对话(session)，客户端和服务器端都生成一个“对话密钥”(session key)，用它来加密信息。由于“对话密钥”是对称加密，所以运算速度非常快，而服务器公钥
只用于加密“对话密钥”本身，这样就减少了加密运算的消耗时间。
```

因此，SSL/TLS协议的基本过程是这样的：
```
- 1、客户端向服务器端索要并验证公钥

- 2、双方协商生成“对话密钥”

- 3、双方采用“对话密钥”进行加密通信
```

上面过程的前两步，又称为“握手阶段”(handshake)

### 握手阶段的详细过程

TLS Client 发送 ClientHello 到TLS Server

TLS Server 返回 ServerHello、ServerCertificate、ServerKeyExchange、CerttificateRequest、ServerHelloDone 给TLS Client

TLS Client 发送 ClientCertificate、ClientKeyExchange、CertificateVerify、ChangeCipherSpec、Finished 到TLS Server

TLS Server 返回 ClientCertificate、ClientKeyExchange、CertificateVerify、ChangeCipherSpec、Finished给 TLs Client

“握手阶段”涉及四次通信，需要注意的是，“握手阶段”的所有通信都是明文的。

#### 客户端发出请求(ClientHello)

首先，客户端先向浏览器发出加密通信的请求,在这一步，客户端主要向服务器提供以下信息。
```
- 1、支持的协议版本，比如TLS1.0版

- 2、一个客户端生成的随机数，稍后用于生成“对话密钥”

- 3、支持的加密算法，比如RSA公钥加密

- 4、支持的压缩方法
```

#### 服务器回应(ServerHello)

服务器收到客户端请求后，向客户端发出回应,服务器的回应主要包含以下内容：
```
- 1、确认使用的加密通信协议版本，比如TLS协议版本，如果客户端与服务器支持的版本不一致，服务器关闭加密通信。

- 2、一个服务器生成的随机数，稍后用于生成“对话密钥”

- 3、确认使用的加密方法

- 4、服务器证书
```

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”。

#### 客户端回应

客户端收到回应后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。

如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项信息：
```
- 1、一个随机数。该随机数用服务器公钥加密，防止被窃听。

- 2、编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

- 3、客户端握手结束通知，表示客户端的握手阶段已经结束，这一项同时也是前面发送的所有内容的hash值，用来提供服务器校验。
```

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称“pre-master key”，有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的
同一把“会话密钥”。

至于为什么一定要用三个随机数：
```
"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。

对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。

pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。"
```

#### 服务器的最后回应

服务器收到客户端的第三个随机数pre-master key 之后，计算生成本次会话所用的"会话密钥"，然后，向客户端最后发送下面信息：
```
- 1、编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。

- 2、服务器握手阶段结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验
```

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用“会话密钥”加密内容。

### x509证书(公钥证书的格式标准)

X.509 标准规定了证书可以包含什么信息，并说明了记录信息的方法（数据格式）。除了签名外，所有 X.509 证书还包含以下数据

**版本**
识别用于该证书的 X.509 标准的版本，这可以影响证书中所能指定的信息。迄今为止，已定义的版本有三个。
**序列号**
发放证书的实体有责任为证书指定序列号，以使其区别于该实体发放的其它证书。此信息用途很多。例如，如果某一证书被撤消，其序列号将放到证书撤消清单 (CRL) 中。
**签名算法标识符**
用于识别 CA 签写证书时所用的算法。
**签发人姓名**
签写证书的实体的 X.500 名称。它通常为一个 CA。 使用该证书意味着信任签写该证书的实体（注意：有些情况下（例如根或顶层 CA 证书），签发人会签写自己的证书）。
**有效期**
每个证书均只能在一个有限的时间段内有效。该有效期以起始日期和时间及终止日期和时间表示，可以短至几秒或长至一世纪。所选有效期取决于许多因素，例如用于签写证书的私钥的使用频率及愿为证书支付的金钱等。它是在没有危及相关私钥的条件下，实体可以依赖公钥值的预计时间。
**主体名**
证书可以识别其公钥的实体名。此名称使用 X.500 标准，因此在Internet中应是唯一的。它是实体的特征名 (DN)，例如，
CN=Java Duke，OU=Java Software Division，O=Sun Microsystems Inc，C=US
（这些指主体的通用名、组织单位、组织和国家）。
**主体公钥信息**
这是被命名实体的公钥，同时包括指定该密钥所属公钥密码系统的算法标识符及所有相关的密钥参数。

常见的X.509证书格式包括：
```
cer/crt是用于存放证书，它是2进制形式存放的，不含私钥。

pem跟crt/cer的区别是它以Ascii来表示，可以用于存放证书或私钥。

pfx/p12用于存放个人证书/私钥，他通常包含保护密码，2进制方式。

p10是证书请求。

p7r是CA对证书请求的回复，只用于导入

p7b以树状展示证书链(certificate chain)，同时也支持单个证书，不含私钥。
```